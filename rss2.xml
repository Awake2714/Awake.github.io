<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Awake&#39;s Blog</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Thu, 13 Jun 2019 10:12:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>递归</title>
      <link>http://yoursite.com/2019/06/13/20_%E9%80%92%E5%BD%92/</link>
      <guid>http://yoursite.com/2019/06/13/20_%E9%80%92%E5%BD%92/</guid>
      <pubDate>Thu, 13 Jun 2019 10:10:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;在一个函数内部可以调用其他函数，也可以自己调用自己，在函数内部自己调用自己就叫做递归&lt;br&gt;递归的出口：当函数满足某一条件时不再执行&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>在一个函数内部可以调用其他函数，也可以自己调用自己，在函数内部自己调用自己就叫做递归<br>递归的出口：当函数满足某一条件时不再执行<a id="more"></a></p><h3 id="写一个递归"><a href="#写一个递归" class="headerlink" title="写一个递归"></a>写一个递归</h3><blockquote></blockquote><pre><code>def sum_nums(num):    print(num)    sum_nums(num-1)sum_nums(3)&gt;&gt;&gt;RecursionError: maximum recursion depth exceeded while calling a Python object</code></pre><p>这样的输出会报错，为什么呢？因为我们说递归是有出口的，递归有深度，如果没有出口就会溢出</p><h3 id="将代码改良"><a href="#将代码改良" class="headerlink" title="将代码改良"></a>将代码改良</h3><blockquote></blockquote><pre><code>def nums(num):    print(num)    if num==1:        return    nums(num-1)nums(3)&gt;&gt;&gt;3   2   1</code></pre><p>给递归指定了一个出口，当num=1时，就直接return</p><h3 id="递归累加求和：1-2-3-…-n"><a href="#递归累加求和：1-2-3-…-n" class="headerlink" title="递归累加求和：1+2+3+…+n"></a>递归累加求和：1+2+3+…+n</h3><blockquote></blockquote><pre><code>def sum_nums(num):    if num==1:        return 1    temp = num-1    return num+sum_nums(temp)results = sum_nums(3)print(results)&gt;&gt;&gt;6</code></pre><h3 id="同理，累乘：1-2-3-…-n"><a href="#同理，累乘：1-2-3-…-n" class="headerlink" title="同理，累乘：1*2*3*…*n"></a>同理，累乘：1*2*3*…*n</h3><blockquote></blockquote><pre><code>def sum_nums(num):    if num==1:        return 1    temp = num-1    return num*sum_nums(temp)results = sum_nums(5)print(results)&gt;&gt;&gt;120</code></pre><p>推荐教程：<a href="https://www.bilibili.com/video/av14184325/?p=357" target="_blank" rel="noopener">https://www.bilibili.com/video/av14184325/?p=357</a></p><p>今天也是努力的一天  ↖(^ω^)↗</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/13/20_%E9%80%92%E5%BD%92/#disqus_thread</comments>
    </item>
    
    <item>
      <title>单例设计模式</title>
      <link>http://yoursite.com/2019/06/13/19_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <guid>http://yoursite.com/2019/06/13/19_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <pubDate>Thu, 13 Jun 2019 08:44:22 GMT</pubDate>
      <description>
      
        &lt;p&gt;这两天在看面试资料，发现有好多东西都忘了，开始查漏补缺，终于弄懂了单例设计模式是个什么鬼&lt;br&gt;我们知道__init__方法是初始化方法，那么__new__方法呢？__new__方法在创建对象时会自动调用，作用是为创建对象，对象分配空间&lt;br&gt;单例模式就是让类创建的对象在系统中只有唯一一个实例，即每次返回的对象的内存地址是相同的&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>这两天在看面试资料，发现有好多东西都忘了，开始查漏补缺，终于弄懂了单例设计模式是个什么鬼<br>我们知道__init__方法是初始化方法，那么__new__方法呢？__new__方法在创建对象时会自动调用，作用是为创建对象，对象分配空间<br>单例模式就是让类创建的对象在系统中只有唯一一个实例，即每次返回的对象的内存地址是相同的<a id="more"></a></p><h3 id="没有用到单例模式时的输出"><a href="#没有用到单例模式时的输出" class="headerlink" title="没有用到单例模式时的输出"></a>没有用到单例模式时的输出</h3><blockquote></blockquote><pre><code>class MusicPlayer(object):    def __init__(self):        print(&apos;初始化方法&apos;)player1 = MusicPlayer()player2 = MusicPlayer()print(player1)print(player2)#创建两个对象，那么返回的内存地址是不一样的，输出&gt;&gt;&gt;初始化方法   初始化方法   &lt;__main__.MusicPlayer object at 0x0000000000B1B278&gt;   &lt;__main__.MusicPlayer object at 0x0000000000B1B2E8&gt;</code></pre><p>那么如何让两个对象的内存地址一样呢，这就要用到单例模式，要写一个单例模式就要用到__new__方法</p><h3 id="写一个单例模式"><a href="#写一个单例模式" class="headerlink" title="写一个单例模式"></a>写一个单例模式</h3><blockquote></blockquote><pre><code>class MusicPlayer(object):    def __new__(cls, *args,**kwargs):        print(&apos;创建对象，分配空间&apos;)        instance = super().__new__(cls)  #调用父类的方法，为对象分配空间        return instance  #返回对象保存在内存空间的引用，一定要返回，否则__init__接收不到    def __init__(self):        print(&apos;初始化方法&apos;)player1 = MusicPlayer()print(player1)player2 = MusicPlayer()print(player2)&gt;&gt;&gt;创建对象，分配空间   初始化方法   &lt;__main__.MusicPlayer object at 0x000000000105B2E8&gt;   创建对象，分配空间   初始化方法   &lt;__main__.MusicPlayer object at 0x00000000010FCE80&gt;</code></pre><p>如果__new__没有返回对象的引用会发生什么呢？</p><h3 id="如果没有return-instance会发生什么？"><a href="#如果没有return-instance会发生什么？" class="headerlink" title="如果没有return instance会发生什么？"></a>如果没有return instance会发生什么？</h3><blockquote></blockquote><pre><code>class MusicPlayer(object):    def __new__(cls, *args,**kwargs):        print(&apos;创建对象，分配空间&apos;)        super().__new__(cls)  #调用父类的方法，为对象分配空间    def __init__(self):        print(&apos;初始化方法&apos;)player1 = MusicPlayer()print(player1)&gt;&gt;&gt;创建对象，分配空间   None</code></pre><p>诶，我们可以看到，如果没有return instance，__init__方法就不会执行，所以一定要返回对象的引用。</p><h3 id="单例模式的完善"><a href="#单例模式的完善" class="headerlink" title="单例模式的完善"></a>单例模式的完善</h3><p>现在将这个代码完善一下，让他如果是第一个对象就为他分配空间，否则，就直接沿用上一个对象的分配空间</p><blockquote></blockquote><pre><code>class MusicPlayer(object):    instance = None  #定义一个类属性为空对象    def __new__(cls, *args,**kwargs):        if cls.instance is None:  #判断instance是否为空对象            cls.instance = super().__new__(cls)  #如果是空对象，那么就为对象分配空间，保存在instance中        return cls.instance  #返回对象的引用player = MusicPlayer()print(player)player2 = MusicPlayer()print(player2)&gt;&gt;&gt;&lt;__main__.MusicPlayer object at 0x0000000000A7B240&gt;   &lt;__main__.MusicPlayer object at 0x0000000000A7B240&gt;</code></pre><h3 id="初始化动作只执行一次"><a href="#初始化动作只执行一次" class="headerlink" title="初始化动作只执行一次"></a>初始化动作只执行一次</h3><p>在上面的代码中我们可以看到，如果有两个player对象，单例模式返回相同的内存地址，但是，创建了两个对象就执行了两次__init__，那么怎么让代码只执行一次呢？</p><blockquote></blockquote><pre><code>class MusicPlayer(object):    instance = None     init_flag = False  #定义一个是否执行初始化动作的标记，设置为False    def __new__(cls, *args,**kwargs):        print(&apos;创建对象、分配空间&apos;)        if cls.instance is None:            cls.instance = super().__new__(cls)        return cls.instance    def __init__(self):            if self.init_flag:  #如果执行了则直接返回            return        print(&apos;初始化方法&apos;)  #如果没有执行，则执行初始化动作        self.init_flag = True  #修改初始化标记player = MusicPlayer()print(player)player2 = MusicPlayer()print(player2)&gt;&gt;&gt;创建对象、分配空间   初始化方法   &lt;__main__.MusicPlayer object at 0x0000000000A7B240&gt;   创建对象、分配空间   &lt;__main__.MusicPlayer object at 0x0000000000A7B240&gt;</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/13/19_%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python爬取百度翻译</title>
      <link>http://yoursite.com/2019/06/02/18_%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91/</link>
      <guid>http://yoursite.com/2019/06/02/18_%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91/</guid>
      <pubDate>Sun, 02 Jun 2019 14:40:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;今天来捣鼓了一下百度翻译&lt;br&gt;目标网址：&lt;a href=&quot;https://fanyi.baidu.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://fanyi.baidu.com&lt;/a&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>今天来捣鼓了一下百度翻译<br>目标网址：<a href="https://fanyi.baidu.com" target="_blank" rel="noopener">https://fanyi.baidu.com</a><a id="more"></a></p><ul><li>表单数据里面有个sign需要获取，这需要执行js代码。</li><li>表单数据里还有一个token，网上有些资料是从请求<a href="https://fanyi.baidu.com" target="_blank" rel="noopener">https://fanyi.baidu.com</a> 的源代码里用正则提取出来的，但是我试了不行。提取出来的和浏览器上看到的并不一样。卡了很久，发现他似乎是没有变的，所以直接给copy过来了。</li><li>请求头里面有个cookie，这个好像也是很久没有变的，So，可以直接从浏览器的开发者工具里面复制过来。</li></ul><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>实现自动翻译</li><li>了解js代码的调试</li><li>熟悉pyexecjs库的基本操作</li></ul><h2 id="获取签名"><a href="#获取签名" class="headerlink" title="获取签名"></a>获取签名</h2><p>通过执行js代码获取sign<br>这一步需要使用到pyexecjs库，基本操作</p><blockquote><p>sign = execjs.compile(js).call(‘e’, word)<br>#执行js代码，将word传给函数e</p></blockquote><h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><p>我们在这里没有定义输入输出语种，仅设置表单数据里的“from”和“key”键的值为“auto”（自动）<br>需要对百度翻译的字符串解码后返回解析</p><blockquote><p>return r.text.encode(‘utf-8’).decode(‘unicode_escape’)</p></blockquote><h2 id="解析网页"><a href="#解析网页" class="headerlink" title="解析网页"></a>解析网页</h2><p>获取翻译后的内容，呈现给用户</p><p>定义了一个循环，当用户输入“n”时，退出程序，否则继续翻译</p><p>完整代码地址：<a href="https://github.com/Awake2714/BaiduFanyi" target="_blank" rel="noopener">https://github.com/Awake2714/BaiduFanyi</a> （喜欢的话给我一个小星星好吗(*^__^*) 嘻嘻……）<br>参考视频教程：<a href="https://www.bilibili.com/video/av25542134?t=1152" target="_blank" rel="noopener">https://www.bilibili.com/video/av25542134?t=1152</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/02/18_%E7%99%BE%E5%BA%A6%E7%BF%BB%E8%AF%91/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python装饰器</title>
      <link>http://yoursite.com/2019/06/01/16_%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <guid>http://yoursite.com/2019/06/01/16_%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <pubDate>Sat, 01 Jun 2019 07:29:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;Python的装饰器是在不影响原有函数的功能的基础上，还能添加新的功能&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Python的装饰器是在不影响原有函数的功能的基础上，还能添加新的功能<a id="more"></a><br>如果理解到了闭包，那么就能很好理解装饰器了。<br>要使用一个装饰器，就在函数上方添加一行代码：@装饰器</p><ol><li>写一个装饰器函数</li></ol><blockquote><p>def func1(func): #外部闭包函数是被装饰的函数对象<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘mua~’)<br>&nbsp;&nbsp;&nbsp;&nbsp;def func2():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘hi’)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func() #返回外部函数接受的被装饰函数的调用<br>&nbsp;&nbsp;&nbsp;&nbsp;return func2 #返回了函数对象<br>@func1<br>def myprint():<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘hello’)<br>myprint() # func1(myprint)() #接受被装饰的函数作为参数，并继续调用一次<br>>&gt;&gt;mua~<br>>&gt;&gt;hi<br>>&gt;&gt;hello</p></blockquote><ul><li>定义一个func1函数，内部嵌套func2并返回func2函数对象；在func2内部返回了对func()的调用<br>在这里我们就对myprint函数使用了装饰器函数func1，@func1 相当于执行func1(myprint)()：将myprint函数对象作为参数传给func1并执行了一次调用，得到一条print语句和返回的func2对象，又执行了func2()，返回func()的调用，这里的func就是func1接受过来的参数myprint</li><li>这个装饰器除了执行被装饰的函数myprint的代码，还执行了func1内部的代码</li></ul><ol start="2"><li>带参数的装饰器函数</li></ol><blockquote><p>def func1(sex):<br>&nbsp;&nbsp;&nbsp;&nbsp;def func2(func):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def func3():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sex == ‘man’:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘不能生孩子’)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sex == ‘woman’:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘可以生孩子 ‘)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func3<br>&nbsp;&nbsp;&nbsp;&nbsp;return func2<br>@func1(sex=’man’)<br>def man():<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘好好上班’)<br>@func1(sex=’woman’)<br>def woman():<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘好好上班’)<br>man()<br>woman()<br>>&gt;&gt;不能生孩子<br>>&gt;&gt;好好上班<br>>&gt;&gt;可以生孩子<br>>&gt;&gt;好好上班</p></blockquote><ul><li>如果要给装饰器函数传入参数，可以在上面所示的装饰器外部再写一个函数，这个函数用来接收参数</li></ul><ol start="3"><li>被装饰的函数带参数</li></ol><blockquote><p>def func1(func):<br>&nbsp;&nbsp;&nbsp;&nbsp;def func2(a,b):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(a,b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a+=5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b+=5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func(a,b)<br>&nbsp;&nbsp;&nbsp;&nbsp;return func2<br>@func1<br>def mysum(a,b):<br>&nbsp;&nbsp;&nbsp;&nbsp;print(a+b)<br>mysum(1, 2)<br>>&gt;&gt;1 2<br>>&gt;&gt;13</p></blockquote><ul><li>如果被装饰的函数需要带参数，只需要在最内部的函数传入参数即可</li></ul><hr><p>总结：</p><ul><li>写一个普通的装饰器，最外部的函数用来接收函数对象，内部的函数不需要其他参数，用来返回函数调用；</li><li>写一个带参数的装饰器，在1的基础上再最外部封装一个函数，用来接收装饰器函数的参数；</li><li>写一个带参数的被装饰的函数的装饰器，最内的函数用来接收参数并返回函数的调用。<br>我表达不好，推荐B站一个将闭包和装饰器讲得很好的教程：<a href="https://www.bilibili.com/video/av18586448?t=2207" target="_blank" rel="noopener">https://www.bilibili.com/video/av18586448?t=2207</a></li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/01/16_%E8%A3%85%E9%A5%B0%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python函数闭包</title>
      <link>http://yoursite.com/2019/06/01/15_%E9%97%AD%E5%8C%85/</link>
      <guid>http://yoursite.com/2019/06/01/15_%E9%97%AD%E5%8C%85/</guid>
      <pubDate>Sat, 01 Jun 2019 07:13:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;函数闭包是内部函数对外部函数作用域里的变量的引用&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>函数闭包是内部函数对外部函数作用域里的变量的引用<a id="more"></a></p><ul><li>函数内的属性都是有生命周期的，都是在函数执行期间</li><li>闭包内的闭包函数私有化了变量，完成了数据的封装，类似于面向对象</li></ul><blockquote><p>def func(): #外部函数<br>&nbsp;&nbsp;&nbsp;&nbsp;a = 1 #外部函数作用域里的变量<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘this is func’)<br>&nbsp;&nbsp;&nbsp;&nbsp;def func1(num): #内部函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘this is func1’)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(num+a)<br>&nbsp;&nbsp;&nbsp;&nbsp;return func1 #函数<br>var = func() #运行外部函数，内部函数就被创建<br>var(2)<br>>&gt;&gt;this is func<br>>&gt;&gt;this is func1<br>>&gt;&gt;3</p></blockquote><p>在func里嵌套了一个func1，将func()函数的调用赋值给var，执行一条print语句，并接收func返回的func1函数对象，这时的var就相当于func1，var(2)传入参数2，调用func1，执行func1内部的代码</p><blockquote><p>mylist = [1,2,3,4,5]<br>def func(obj):<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘func:’, obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;def func1():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj[0] += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘func1:’, obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;return func1<br>var = func(mylist)<br>var()<br>var()<br>var()<br>>&gt;&gt;func: [1, 2, 3, 4, 5]<br>>&gt;&gt;func1: [2, 2, 3, 4, 5]<br>>&gt;&gt;func1: [3, 2, 3, 4, 5]<br>>&gt;&gt;func1: [4, 2, 3, 4, 5]</p></blockquote><p>在这里，首先我们定义了一个mylist列表；其次定义了一个func函数，传入参数obj，执行一条print语句，在函数内部嵌套了一个func1，并将func1对象返回。在func1里，改变object索引为0的值，接着打印了obj。<br>将mylist作为参数传给func，这里的var如上面的例子一样，相当于func1，接着调用了三次var()，可以看到每一次调用后打印的obj都在上一次调用的基础上加了1.<br>我表达不好，推荐B站一个将闭包和装饰器讲得很好的教程：<a href="https://www.bilibili.com/video/av18586448?t=2207" target="_blank" rel="noopener">https://www.bilibili.com/video/av18586448?t=2207</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/01/15_%E9%97%AD%E5%8C%85/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Awake&#39;s Blog</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sat, 01 Jun 2019 08:25:24 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Python装饰器</title>
      <link>http://yoursite.com/2019/06/01/16_%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <guid>http://yoursite.com/2019/06/01/16_%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <pubDate>Sat, 01 Jun 2019 07:29:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;Python的装饰器是在不影响原有函数的功能的基础上，还能添加新的功能&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Python的装饰器是在不影响原有函数的功能的基础上，还能添加新的功能<a id="more"></a><br>如果理解到了闭包，那么就能很好理解装饰器了。<br>要使用一个装饰器，就在函数上方添加一行代码：@装饰器</p><ol><li>写一个装饰器函数</li></ol><blockquote><p>def func1(func): #外部闭包函数是被装饰的函数对象<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘mua~’)<br>&nbsp;&nbsp;&nbsp;&nbsp;def func2():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘hi’)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func() #返回外部函数接受的被装饰函数的调用<br>&nbsp;&nbsp;&nbsp;&nbsp;return func2 #返回了函数对象<br>@func1<br>def myprint():<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘hello’)<br>myprint() # func1(myprint)() #接受被装饰的函数作为参数，并继续调用一次<br>>&gt;&gt;mua~<br>>&gt;&gt;hi<br>>&gt;&gt;hello</p></blockquote><ul><li>定义一个func1函数，内部嵌套func2并返回func2函数对象；在func2内部返回了对func()的调用<br>在这里我们就对myprint函数使用了装饰器函数func1，@func1 相当于执行func1(myprint)()：将myprint函数对象作为参数传给func1并执行了一次调用，得到一条print语句和返回的func2对象，又执行了func2()，返回func()的调用，这里的func就是func1接受过来的参数myprint</li><li>这个装饰器除了执行被装饰的函数myprint的代码，还执行了func1内部的代码</li></ul><ol start="2"><li>带参数的装饰器函数</li></ol><blockquote><p>def func1(sex):<br>&nbsp;&nbsp;&nbsp;&nbsp;def func2(func):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def func3():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sex == ‘man’:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘不能生孩子’)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sex == ‘woman’:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘可以生孩子 ‘)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func3<br>&nbsp;&nbsp;&nbsp;&nbsp;return func2<br>@func1(sex=’man’)<br>def man():<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘好好上班’)<br>@func1(sex=’woman’)<br>def woman():<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘好好上班’)<br>man()<br>woman()<br>>&gt;&gt;不能生孩子<br>>&gt;&gt;好好上班<br>>&gt;&gt;可以生孩子<br>>&gt;&gt;好好上班</p></blockquote><ul><li>如果要给装饰器函数传入参数，可以在上面所示的装饰器外部再写一个函数，这个函数用来接收参数</li></ul><ol start="3"><li>被装饰的函数带参数</li></ol><blockquote><p>def func1(func):<br>&nbsp;&nbsp;&nbsp;&nbsp;def func2(a,b):<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(a,b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a+=5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b+=5<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return func(a,b)<br>&nbsp;&nbsp;&nbsp;&nbsp;return func2<br>@func1<br>def mysum(a,b):<br>&nbsp;&nbsp;&nbsp;&nbsp;print(a+b)<br>mysum(1, 2)<br>>&gt;&gt;1 2<br>>&gt;&gt;13</p></blockquote><ul><li>如果被装饰的函数需要带参数，只需要在最内部的函数传入参数即可</li></ul><hr><p>总结：</p><ul><li>写一个普通的装饰器，最外部的函数用来接收函数对象，内部的函数不需要其他参数，用来返回函数调用；</li><li>写一个带参数的装饰器，在1的基础上再最外部封装一个函数，用来接收装饰器函数的参数；</li><li>写一个带参数的被装饰的函数的装饰器，最内的函数用来接收参数并返回函数的调用。<br>我表达不好，推荐B站一个将闭包和装饰器讲得很好的教程：<a href="https://www.bilibili.com/video/av18586448?t=2207" target="_blank" rel="noopener">https://www.bilibili.com/video/av18586448?t=2207</a></li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/01/16_%E8%A3%85%E9%A5%B0%E5%99%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python函数闭包</title>
      <link>http://yoursite.com/2019/06/01/15_%E9%97%AD%E5%8C%85/</link>
      <guid>http://yoursite.com/2019/06/01/15_%E9%97%AD%E5%8C%85/</guid>
      <pubDate>Sat, 01 Jun 2019 07:13:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;函数闭包是内部函数对外部函数作用域里的变量的引用&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>函数闭包是内部函数对外部函数作用域里的变量的引用<a id="more"></a></p><ul><li>函数内的属性都是有生命周期的，都是在函数执行期间</li><li>闭包内的闭包函数私有化了变量，完成了数据的封装，类似于面向对象</li></ul><blockquote><p>def func(): #外部函数<br>&nbsp;&nbsp;&nbsp;&nbsp;a = 1 #外部函数作用域里的变量<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘this is func’)<br>&nbsp;&nbsp;&nbsp;&nbsp;def func1(num): #内部函数<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘this is func1’)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(num+a)<br>&nbsp;&nbsp;&nbsp;&nbsp;return func1 #函数<br>var = func() #运行外部函数，内部函数就被创建<br>var(2)<br>>&gt;&gt;this is func<br>>&gt;&gt;this is func1<br>>&gt;&gt;3</p></blockquote><p>在func里嵌套了一个func1，将func()函数的调用赋值给var，执行一条print语句，并接收func返回的func1函数对象，这时的var就相当于func1，var(2)传入参数2，调用func1，执行func1内部的代码</p><blockquote><p>mylist = [1,2,3,4,5]<br>def func(obj):<br>&nbsp;&nbsp;&nbsp;&nbsp;print(‘func:’, obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;def func1():<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;obj[0] += 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(‘func1:’, obj)<br>&nbsp;&nbsp;&nbsp;&nbsp;return func1<br>var = func(mylist)<br>var()<br>var()<br>var()<br>>&gt;&gt;func: [1, 2, 3, 4, 5]<br>>&gt;&gt;func1: [2, 2, 3, 4, 5]<br>>&gt;&gt;func1: [3, 2, 3, 4, 5]<br>>&gt;&gt;func1: [4, 2, 3, 4, 5]</p></blockquote><p>在这里，首先我们定义了一个mylist列表；其次定义了一个func函数，传入参数obj，执行一条print语句，在函数内部嵌套了一个func1，并将func1对象返回。在func1里，改变object索引为0的值，接着打印了obj。<br>将mylist作为参数传给func，这里的var如上面的例子一样，相当于func1，接着调用了三次var()，可以看到每一次调用后打印的obj都在上一次调用的基础上加了1.<br>我表达不好，推荐B站一个将闭包和装饰器讲得很好的教程：<a href="https://www.bilibili.com/video/av18586448?t=2207" target="_blank" rel="noopener">https://www.bilibili.com/video/av18586448?t=2207</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/01/15_%E9%97%AD%E5%8C%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>lambda匿名函数</title>
      <link>http://yoursite.com/2019/06/01/14_lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</link>
      <guid>http://yoursite.com/2019/06/01/14_lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Sat, 01 Jun 2019 06:40:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;lambda匿名函数学习&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>lambda匿名函数学习<a id="more"></a></p><ul><li>lambda [arg1 [,arg2,…..argn]]:expression</li><li>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。</li><li>lambda的格式：冒号前是参数，可以有多个，用逗号隔开，冒号右边的为表达式。lambda返回值是一个函数的地址，也就是函数对象。</li></ul><ol><li>lambda与map一起使用</li></ol><blockquote><p>x = [1, 2, 3, 4]<br>results = list(map(lambda x: x*x, x))<br>print()<br>>&gt;&gt;[1, 4, 9, 16]</p></blockquote><ol start="2"><li>把lambda赋值给一个变量，再利用变量来调用函数</li></ol><blockquote><p>results = lambda x, y: x+y<br>print(results(5, 6))<br>>&gt;&gt;11</p></blockquote><ol start="3"><li>根据age对字典排序</li></ol><blockquote><p>infors=[{“name”:”wang”,”age”:10},{“name”:”xiaoming”,”age”:20},{“name”:”banzhang”,”age”:10}]<br>infors.sort(key=lambda x:x[‘age’])<br>print(infors)<br>>&gt;&gt;[{‘age’: 10, ‘name’: ‘wang’}, {‘age’: 10, ‘name’: ‘banzhang’}, {‘age’: 20, ‘name’: ‘xiaoming’}]</p></blockquote><ol start="4"><li>把lambda作为函数返回</li></ol><blockquote><p>def add(x,y):<br>&nbsp;&nbsp;&nbsp;&nbsp;return lambda: x+y</p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/01/14_lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>map()函数</title>
      <link>http://yoursite.com/2019/06/01/13_map%E5%87%BD%E6%95%B0/</link>
      <guid>http://yoursite.com/2019/06/01/13_map%E5%87%BD%E6%95%B0/</guid>
      <pubDate>Sat, 01 Jun 2019 06:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;map()是Python内置的高阶函数&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>map()是Python内置的高阶函数<a id="more"></a></p><ul><li>map函数的原型是map(function, iterable, …)，它返回一个列表</li><li>将function应用于iterable的每个元素，参数iterable是一个可迭代的对象，例如：列表，元祖，字符串</li><li>后面的省略号表示可以传很多个iterable，并行从这些参数中取元素，并调用function。</li></ul><ol><li>function为内置函数：将a的每个元素转化为字符串</li></ol><blockquote><p>a = [1, 2, 3, 4]<br>fruit = list(map(str, a))<br>print(fruit)<br>>&gt;&gt;[‘1’, ‘2’, ‘3’, ‘4’]</p></blockquote><ol start="2"><li>function为自定义函数：将a内的每个元素应用multiplication方法</li></ol><blockquote><p>def multiplication(a):<br>&nbsp;&nbsp;&nbsp;&nbsp;b = a*a<br>&nbsp;&nbsp;&nbsp;&nbsp;return b<br>results = list(map(multiplication, a))<br>print(results)<br>>&gt;&gt;[1, 4, 9, 16]</p></blockquote><ol start="3"><li>自定义函数传入多个参数：并行从x、y中取出元素，传入add函数中</li></ol><blockquote><p>x = [1, 2, 3]<br>y = [4, 5, 6]<br>def add(x, y):<br>&nbsp;&nbsp;&nbsp;&nbsp;return x+y<br>ending = list(map(add, x, y))<br>print(ending)<br>>&gt;&gt;[5, 7, 9]</p></blockquote><ol start="4"><li>传入的参数元素个数不一致，map函数按元素最少的参数返回值</li></ol><blockquote><p>x = [1, 2, 3]<br>y = [4, 5, 6, 7]<br>def x_y(x, y):<br>&nbsp;&nbsp;&nbsp;&nbsp;return x, y<br>outcome = list(map(x_y, x, y))<br>print(outcome)<br>>&gt;&gt;[(1, 4), (2, 5), (3, 6)]</p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/01/13_map%E5%87%BD%E6%95%B0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>列表去重</title>
      <link>http://yoursite.com/2019/06/01/12_%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D/</link>
      <guid>http://yoursite.com/2019/06/01/12_%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D/</guid>
      <pubDate>Sat, 01 Jun 2019 05:27:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;列表去重有这几种方法：&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>列表去重有这几种方法：<a id="more"></a></p><ol><li>使用内置的set去重</li></ol><blockquote><p>a = [‘b’, ‘a’, ‘b’, ‘d’, ‘c’, ‘a’]<br>b = list(set(a))<br>print(b)<br>>&gt;&gt;[‘a’, ‘b’, ‘c’, ‘d’]</p></blockquote><ol start="2"><li>使用字典</li></ol><blockquote><p>c = list({}.fromkeys(a).keys())<br>print(c)<br>>&gt;&gt;[‘a’, ‘b’, ‘c’, ‘d’]</p></blockquote><p>使用以上两种方法，可以观察到输出后的列表元素的顺序被打乱了，如果想要列表保持原来的顺序，可以这样做：</p><blockquote><p>b.sort(key=a.index)<br>print(‘排序后的b：’,b)<br>d = sorted(c, key=a.index)<br>print(‘排序后的c：’,d)<br>>&gt;&gt;排序后的b： [‘b’, ‘a’, ‘d’, ‘c’]<br>>&gt;&gt;排序后的c： [‘b’, ‘a’, ‘d’, ‘c’]</p></blockquote><ol start="3"><li>列表去重，不改变原列表的顺序</li></ol><blockquote><p>d = []<br>for x in a:<br>&nbsp;&nbsp;&nbsp;&nbsp;if not x in d:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d.append(x)<br>print(d)<br>>&gt;&gt;d： [‘b’, ‘a’, ‘d’, ‘c’]</p></blockquote><ol start="4"><li>列表推导式的写法</li></ol><blockquote><p>f = []<br>g = [f.append(y) for y in a if y not in f]<br>print(‘f:’,f)<br>>&gt;&gt;f: [‘b’, ‘a’, ‘d’, ‘c’]</p></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/06/01/12_%E5%88%97%E8%A1%A8%E5%8E%BB%E9%87%8D/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
